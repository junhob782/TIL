# [Study] 자료구조 기본 (02/10)

## 1. 자료구조 (Data Structure) 개요
* **정의**: 자료를 효율적으로 표현, 저장, 처리할 수 있도록 정리하는 것.
* **목표**: 자료를 **빠르게 탐색(Search)** 하는 것.

### 1.1 자료구조의 분류
1.  **단순 구조 (Simple)**
    * 정수(Integer), 실수(Float), 문자(Char), 문자열(String) 등의 기본 자료형.
2.  **선형 구조 (Linear)**
    * 자료들 사이의 관계가 **1:1 관계**.
    * 종류: `{순차 리스트, 연결 리스트, 스택, 큐, 데크}`
3.  **비선형 구조 (Non-Linear)**
    * 자료들 사이의 관계가 **1:多, 多:多 관계**.
    * 종류: `{트리, 그래프}`
4.  **파일 구조 (File)**
    * 서로 관련 있는 필드로 구성된 레코드의 집합인 파일에 대한 구조.
    * 종류: `{순차 파일, 색인 파일, 직접 파일}`

---

## 2. 컴퓨터 구조 기초
* **2의 보수 (2's Complement)**: `1의 보수 + 1`

---

## 3. 추상화와 구체화 (Abstraction vs Concretization)

### 3.1 개념 비교
| 구분 | 내용 | 비고 |
| :--- | :--- | :--- |
| **자료의 추상화** | 기억할 대상의 구별되는 특징만을 단순화하여 기억하는 기능. | |
| **추상 자료형 (ADT)** | 자료와 연산자의 특성을 논리적으로 추상화하여 정의한 자료형. | |
| **추상화 (Abstraction)** | **"무엇인가? (What)"**를 논리적으로 정의. | ADT, 알고리즘 정의 |
| **구체화 (Concretization)** | **"어떻게 할 것인가? (How)"**를 실제적으로 표현. | 자료형, 프로그램 구현 |

---

## 4. 알고리즘 (Algorithm)
* **정의**: 문제 해결 방법을 추상화하여 단계적 절차를 논리적으로 기술해 놓은 것.

### 4.1 알고리즘의 5가지 조건
1.  **입력 (Input)**: 알고리즘 수행에 필요한 자료가 외부에서 입력으로 제공될 수 있어야 함.
2.  **출력 (Output)**: 수행 후 하나 이상의 결과를 출력해야 함.
3.  **명확성 (Definiteness)**: 수행할 작업의 내용과 순서를 나타내는 명령어들은 명확하게 명세되어야 함.
4.  **유한성 (Finiteness)**: 알고리즘은 수행한 뒤 반드시 종료되어야 함.
5.  **효과성 (Effectiveness)**: 모든 명령어들은 기본적이며 실행 가능해야 함.

---

## 5. 소프트웨어 설계 원칙 (Module)
* **응집도 (Cohesion)**: 함수(모듈) 안에서 관련 있는 기능끼리 모아 놓은 정도.
* **결합도 (Coupling)**: 모듈과 모듈 사이가 얼마나 의존적으로 엮여 있는가.
* **설계 목표**: **응집도는 높이고(High Cohesion), 결합도는 낮춰야(Low Coupling) 함.**

---

## 6. 메모리와 포인터 (Memory & Pointer)

### 6.1 연산의 방향
* **포인터 연산**: `주소` $\rightarrow$ `값` (Dereferencing)
* **레퍼런스 연산**: `값` $\rightarrow$ `주소` (Address-of)

### 6.2 복사(Copy)의 종류
* **얕은 복사 (Shallow Copy)**: 주소값만 복사하는 것 (동일한 메모리를 가리킴).
* **깊은 복사 (Deep Copy)**: 실제 데이터까지 메모리를 새로 할당해 복사하는 것 (독립적인 데이터).

---

## 7. 재귀 호출 (Recursion)
* **정의**: 자기 자신을 호출하여 순환 수행되는 것.
* **특징**:
    * 프로그램 크기를 줄이고, 코드를 간단하게 작성 가능.
    * 전체 문제를 한 번에 해결하기보다, 같은 유형의 하위 작업으로 분할하여 해결하는 것이 효율적일 때 사용.
* **베이스 케이스 (Base Case)**: 재귀 호출 과정을 반복하다 보면 한 번에 해결할 수 있을 정도로 분할된 작업 단위가 충분히 작아지는 단계 (종료 조건).

# [Study] 연결 자료구조와 연결 리스트 (02/10)

## 8. 리스트 (List)의 개요
* **정의**: 자료를 구조화하는 가장 기본적인 방법으로 데이터를 나열한 것.
* **구성 요소**:
    * **노드 (Node)**: 연결 자료구조에서 하나의 원소를 표현하기 위한 단위 구조.
    * **데이터 필드 (Data Field)**: 원소의 값을 저장 (형태에 따라 하나 이상의 필드로 구성).
* **선형 리스트 (Linear List)**:
    1.  **순서 리스트**: 자료들 간에 순서를 갖는 리스트.

### 8.1 자료구조의 순서
* **연결 자료구조 (Linked Data Structure)**: 자료의 **논리적인 순서**와 **물리적인 순서**가 불일치함 (포인터로 연결).
* **크기 계산**: `인덱스 번호 + 1` (컴퓨터적 개수) = `사이즈` (물리적 개수).

---

## 9. 연결 리스트 (Linked List) 구조
* **기본 구조**: `Head 노드` - `Current` - `Tail 노드`
* **주요 개념**:
    * **리스트 이름 (Head Pointer)**: 연결 리스트의 시작을 가리키는 포인터 변수.
    * **NULL 포인터**:
        * 연결 리스트의 마지막 노드의 링크 필드에 `NULL` 값을 저장하여 끝을 표시.
        * **공백 연결 리스트**: 포인터 변수(Head)에 `NULL` 저장.
    * **접근 방식**: 각 노드의 필드에 저장한 값은 **점(.) 연산자**를 사용해 액세스함.

---

## 10. 단순 연결 리스트 (Singly Linked List) 연산 

### 10.1 삽입 연산 (Insert)
1.  삽입할 노드를 준비한다.
2.  새 노드의 **데이터 필드**에 값을 저장한다.
3.  새 노드의 **링크 값(Next)**을 지정한다 (삽입할 위치의 다음 노드를 가리킴).
4.  리스트의 **앞 노드(Previous Node)**에 새 노드를 연결한다.

### 10.2 삭제 연산 (Remove)
1.  삭제할 노드의 **앞 노드**를 찾는다.
2.  앞 노드의 링크 필드에 **삭제할 노드의 링크 필드값(다음 노드 주소)**을 저장한다.
3.  삭제한 노드의 앞 노드와 삭제한 노드의 다음 노드를 논리적으로 연결한다. (이후 메모리 해제)

---

## 11. 고급 연결 리스트 (Advanced Linked List)

### 11.1 원형 연결 리스트 (Circular Linked List)
* **정의**: 연결 리스트에서 **마지막 노드**가 리스트의 **첫 번째 노드**를 가리키게 하여 구조를 원형으로 만든 리스트.

### 11.2 이중 연결 리스트 (Doubly Linked List) 
* **정의**: 양쪽 방향으로 순회할 수 있도록 노드를 연결한 리스트.
* **구조**:
    * **`llink` (Left Link)**: 왼쪽(이전) 노드와 연결하는 포인터.
    * **`rlink` (Right Link)**: 오른쪽(다음) 노드와 연결하는 포인터.

---

## 12. 이중 연결 리스트의 연산 로직

### 12.1 노드 삽입 방법 (Insertion Logic)
> *주의: 포인터 갱신 순서가 중요함 (기존 링크를 끊기 전에 주소를 백업해야 함).*

1.  삽입할 노드(`New`)를 준비하고 데이터 필드에 값을 저장한다.
2.  **오른쪽 연결**: `New`의 `rlink`에 `왼쪽 노드(Left)`의 `rlink` 값(기존의 오른쪽 노드 주소)을 저장한다.
3.  **왼쪽 연결**: `New`의 `llink`에 `왼쪽 노드(Left)`의 주소를 저장한다.
4.  **기존 노드 갱신 1**: `왼쪽 노드(Left)`의 `rlink`에 `New`의 주소를 저장한다.
5.  **기존 노드 갱신 2**: `오른쪽 노드(Right)`의 `llink`에 `New`의 주소를 저장한다.
6.  모든 노드가 순서대로 연결된다.

### 12.2 노드 삭제 과정 (Deletion Logic)
1.  삭제할 노드(`Target`)의 **오른쪽 노드**와 **왼쪽 노드**를 찾는다.
2.  **왼쪽 노드 갱신**: `삭제할 노드의 왼쪽 노드`의 `rlink`에 `삭제할 노드의 오른쪽 노드 주소`를 저장한다.
3.  **오른쪽 노드 갱신**: `삭제할 노드의 오른쪽 노드`의 `llink`에 `삭제할 노드의 왼쪽 노드 주소`를 저장한다.
4.  노드가 순서대로 연결된다. (삭제된 노드는 메모리 해제)

---

## 13. [Core] C언어 메모리 관리 및 안전성 (Memory Safety)
> **아키텍트의 조언**: "C언어에서 `malloc`은 빚을 지는 것과 같습니다. `free`로 갚지 않으면 시스템 파산(Crash)을 초래합니다."

### 13.1 동적 할당의 정석 (Allocation Pattern)
* **원칙**: 메모리 요청(`malloc`) 직후에는 반드시 **성공 여부(`NULL` 체크)**를 검증해야 한다.
* **초기화**: 할당된 메모리에 쓰레기 값(Garbage Value)이 남지 않도록 `memset`이나 `calloc` 사용을 권장.

```c
// [Good Practice] 안전한 할당 패턴
Node* newNode = (Node*)malloc(sizeof(Node));

if (newNode == NULL) {
    // 엣지 케이스 처리: 시스템 메모리 부족
    fprintf(stderr, "[Error] Memory allocation failed.\n");
    exit(1); 
}
// 할당 성공 후 데이터 초기화 필수
newNode->next = NULL;


```
# [Study] 스택의 이해 (02/11)

## 14. 스택 (Stack) 개요
* **정의**: 접시를 쌓듯이 자료를 차곡차곡 쌓아 올린 형태의 자료구조.
* **구조적 특징**:
    * **후입선출 (LIFO: Last-In First-Out)**: 마지막에 삽입한 원소가 맨 위에 있다가 가장 먼저 삭제되는 구조.
    * **접근 제어**: 스택에 저장된 원소는 **Top**으로 정한 곳에서만 접근 가능.
* **주요 연산**:
    * **`push`**: 삽입 연산 (Top 증가).
    * **`pop`**: 삭제 연산 (Top 감소, 데이터 반환).

---

## 15. 시스템 스택 (System Stack)
* **목표**: 프로그램에서의 함수 호출(Call)과 복귀(Return)에 따른 수행 순서를 관리.
* **동작 원리**:
    1.  **호출 순서**: 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀함 (LIFO).
    2.  **스택 프레임 (Stack Frame)**:
        * 함수 호출 발생 시, 수행에 필요한 정보(지역변수, 매개변수, 복귀 주소 등)를 저장하는 단위.
        * 시스템 스택에 `push` 됨.
    3.  **복귀 과정**:
        * 함수 실행이 끝나면 시스템 스택의 **Top 원소(해당 함수의 프레임)**를 `pop` 하여 삭제.
        * 프레임에 저장된 복귀 주소를 확인하여 호출한 지점으로 복귀.
    4.  **종료**: 함수 호출과 복귀를 반복하다 전체 프로그램 수행이 종료되면 시스템 스택은 **공백 스택(Empty)**이 됨.

---

## 16. 수식의 표기법 (Expression Notations)

### 16.1 표기법의 종류
| 종류 | 설명 | 예시 (A+B) |
| :--- | :--- | :--- |
| **전위 표기법 (Prefix)** | 연산자를 피연산자 **앞**에 표기. | `+AB` |
| **중위 표기법 (Infix)** | 연산자를 피연산자 **가운데** 표기 (일반적인 수식). | `A+B` |
| **후위 표기법 (Postfix)** | 연산자를 피연산자 **뒤**에 표기. | `AB+` |

---

## 17. 스택을 활용한 수식 알고리즘

### 17.1 중위 표기법 $\rightarrow$ 후위 표기법 변환 알고리즘
> *컴퓨터 내부에서 스택을 사용하여 변환하는 절차*

1.  **왼쪽 괄호 `(`**: 만나면 무시하고 다음 문자를 읽는다.
2.  **피연산자 (Operand)**: 만나면 즉시 **출력**한다.
3.  **연산자 (Operator)**: 만나면 **스택에 삽입(`push`)**한다.
4.  **오른쪽 괄호 `)`**: 만나면 스택을 **`pop`하여 출력**한다.
5.  **수식 종료**: 수식이 끝나면 스택이 공백이 될 때까지 계속 **`pop`하여 출력**한다.

### 17.2 후위 표기법 수식의 연산 (Evaluation)
> *변환된 수식(예: `AB+`)을 계산하는 절차*

1.  **피연산자**: 만나면 스택에 **`push`**한다.
2.  **연산자**:
    * 만나면 필요한 만큼의 피연산자(보통 2개)를 스택에서 **`pop`**한다.
    * 연산을 수행한다.
    * 연산 결과를 다시 스택에 **`push`**한다.
3.  **수식 종료**: 마지막으로 스택을 **`pop`**하여 최종 결과를 출력한다.


# [Study] 큐 (Queue)와 데크 (Deque) (02/11)

## 18. 큐 (Queue) 개요 
* **정의**: 스택과 비슷하게 삽입과 삭제의 위치가 제한되어 있는 유한 순서 리스트.
* **구조적 특징**:
    * **선입선출 (FIFO: First-In First-Out)**: 뒤(`Rear`)에서는 삽입만 하고, 앞(`Front`)에서는 삭제만 할 수 있는 구조.
* **주요 연산**:
    * **`enQueue`**: 삽입 연산.
    * **`deQueue`**: 삭제 연산.

### 18.1 스택과 큐의 비교
| 구분 | 삽입 연산 (Insert) | 위치 | 삭제 연산 (Delete) | 위치 |
| :--- | :--- | :--- | :--- | :--- |
| **스택 (Stack)** | `push` | Top | `pop` | Top |
| **큐 (Queue)** | `enQueue` | Rear | `deQueue` | Front |

### 18.2 큐의 포인터 관리
* **최대 크기**: `배열의 크기` (순차 큐 기준).
* **변수 역할**:
    * **`front`**: 저장된 **첫 번째 원소**의 인덱스를 저장.
    * **`rear`**: 저장된 **마지막 원소**의 인덱스를 저장.

---

## 19. 순차 큐(Linear Queue)의 문제점과 해결
> **문제 상황**: 잘못된 포화 상태 인식 (False Overflow)

* **현상**: 큐에서 삽입 및 삭제가 반복되면 앞부분(`front` 쪽)에 빈자리가 생기지만, `rear = n-1` 상태가 되어 포화 상태(Full)로 인식하고 더 이상 삽입을 수행하지 않음.

### 19.1 해결 방법
1.  **데이터 이동 (Shifting)**: 저장된 원소들을 배열의 앞부분으로 이동시키기. (비효율적: $O(n)$)
2.  **원형 큐 (Circular Queue)**: 1차원 배열을 사용하면서 논리적으로 배열의 처음과 끝이 연결되어 있다고 가정. (효율적: $O(1)$) 

### 19.2 순차 큐 vs 원형 큐 연산 비교
| 종류 | 삽입 위치 (Rear 계산) | 삭제 위치 (Front 계산) |
| :--- | :--- | :--- |
| **순차 큐** | `rear = rear + 1` | `front = front + 1` |
| **원형 큐** | $rear = (rear + 1) \pmod n$ | $front = (front + 1) \pmod n$ |
> *주석: `mod`는 나머지 연산자(%)를 의미하며, `n`은 큐의 크기.*

---

## 20. 데크 (Deque: Double-ended Queue) 
* **정의**: 큐 두 개 중 하나를 좌우로 뒤집어서 붙인 구조. 큐의 **양쪽 끝(Front & Rear)**에서 삽입과 삭제 연산을 모두 수행할 수 있도록 확장한 자료구조.
* **구현 전략**:
    * **순차 자료구조(배열)의 한계**: 양쪽 끝에서 연산 시 크기 변화와 원소의 순서 변화(Shift)가 많아 비효율적.
    * **권장 구현**: 양방향으로 연산 가능한 **이중 연결 리스트 (Doubly Linked List)** 사용.

---

## 21. 큐의 응용 (Applications)

### 21.1 운영체제 (OS)의 작업 큐
* **프린터 버퍼 큐 (Printer Buffer Queue)**:
    * CPU는 빠르고 프린터는 느림.
    * CPU에서 보낸 데이터를 순서대로(`FIFO`) 출력하기 위해 선입선출 구조 사용.
* **스케줄링 큐 (Scheduling Queue)**:
    * CPU 사용을 요청한 프로세스들의 순서를 스케줄링하기 위해 사용 (준비 큐, 대기 큐 등).

### 21.2 시뮬레이션과 큐잉 이론 (Queuing Theory)
* **정의**: 서비스 대기 행렬(Queue)과 대기 시간 등을 수학적으로 모델링하는 이론.
* **활용**: 은행 창구, 공항 입국 심사, 네트워크 패킷 처리 등 다양한 시스템의 성능 분석 및 최적화 시뮬레이션에 사용.
* 

# [Study] 트리 (Tree)와 이진 트리 (02/11)

## 22. 트리 (Tree)의 개요 

[Image of tree data structure terminology]

* **정의**: 원소 간 **1:n 관계**를 가지는 비선형 자료구조.
* **특징**:
    * 원소들 간에 계층 관계를 가지는 **계층형 자료구조 (Hierarchical)**.
    * 상위 원소에서 하위 원소로 내려가면서 확장되는 나무(Tree) 모양의 구조.

### 22.1 트리의 구성 요소 (Terminology)
* **노드 (Node)**: 트리를 구성하는 원소(Element).
* **루트 노드 (Root Node)**: 트리의 시작점(최상위 노드).
* **간선 (Edge)**: 노드를 연결하는 선 (부모 노드와 자식 노드를 연결).
* **형제 노드 (Sibling)**: 같은 부모를 가진 노드들.
* **조상 노드 (Ancestor)**: 간선을 따라 루트 노드까지 경로에 있는 모든 상위 노드들.
* **서브 트리 (Subtree)**: 부모 노드와 연결된 간선을 끊었을 때 생성되는 하위 트리.
* **자손 노드 (Descendant)**: 서브 트리에 있는 모든 하위 레벨의 노드들.
* **단말 노드 (Leaf Node / Terminal Node)**: 차수가 0인 노드 (자식 노드가 없는 노드).

### 22.2 트리의 차수와 높이 (Degree & Height)
* **노드의 차수 (Degree of Node)**: 한 노드에 연결된 **자식 노드(서브 트리)의 수**.
* **트리의 차수 (Degree of Tree)**: 트리에 있는 노드의 차수 중 **가장 큰 값**.
* **노드의 높이 (Height/Level)**: 루트에서 해당 노드에 이르는 간선의 수 (레벨).
    * *Ex) 루트가 Level 0일 때, 자식 B의 높이 = 1, 손자 F의 높이 = 2*
* **트리의 높이**: 트리에 있는 노드의 높이 중 **가장 큰 값** (최대 깊이).
* **포리스트 (Forest)**: 서브 트리(Subtree)들의 집합 (루트를 제거했을 때 남는 트리들의 모임).

---

## 23. 이진 트리 (Binary Tree)
* **정의**: 트리의 모든 노드의 차수를 **2 이하**로 제한하여, 전체 트리의 차수가 2 이하가 되도록 정의한 것.
* **특성**:
    1.  **간선의 개수**: 노드가 $n$개인 이진 트리는 항상 간선이 **$n-1$개**임.
    2.  **노드의 개수**: 높이가 $h$인 이진 트리가 가질 수 있는 노드 개수는 **최소 $h+1$개**이다. (편향 트리의 경우)

### 23.1 이진 트리의 종류 (Types) 
1.  **포화 이진 트리 (Perfect Binary Tree)**:
    * 모든 레벨에 노드가 꽉 차 있는 상태.
    * 높이가 $h$일 때, 전체 노드 개수는 $2^{h+1} - 1$.
2.  **완전 이진 트리 (Complete Binary Tree)**:
    * 포화 이진 트리에서 노드 번호 1번부터 $n$번까지의 위치와 완전히 일치하는 트리.
    * 마지막 레벨을 제외하고 모든 레벨이 채워져 있으며, 마지막 레벨은 **왼쪽부터** 채워짐.
3.  **편향 이진 트리 (Skewed Binary Tree)**:
    * 높이가 $h$일 때 $h+1$개의 노드를 가지면서, 모든 노드가 **왼쪽**이나 **오른쪽** 중 한 방향으로만 서브 트리를 가지는 트리.

---

## 24. 이진 트리의 배열 표현 (Array Representation)
> **전제 조건**: 루트 노드의 인덱스를 **1**로 설정한다. (배열의 0번 인덱스는 비워둠)

### 24.1 인덱스 계산 공식 (Indexing Formula)
노드 `i`를 기준으로 자식 노드나 부모 노드를 찾을 때 다음 규칙을 따른다.

| 관계 | 인덱스 계산식 | 비고 |
| :--- | :--- | :--- |
| **왼쪽 자식 (Left Child)** | **$2 \times i$** | 현재 인덱스 $\times$ 2 |
| **오른쪽 자식 (Right Child)** | **$2 \times i + 1$** | 현재 인덱스 $\times$ 2 + 1 |
| **부모 노드 (Parent)** | **$i \div 2$** | (나머지 버림) |

* **메모리 효율**:
    * **완전 이진 트리**는 배열 공간을 효율적으로 사용함.
    * **편향 이진 트리**는 배열 사용 시 메모리 낭비(빈 공간)가 심하여, **연결 리스트**로 구현하는 것이 효율적임.
 
    * 
# [Study] 트리 순회와 탐색 (02/11)

## 25. 이진 트리의 순회 (Binary Tree Traversal)
* **기본 원칙**:
    * 이진 트리는 순환적(Recursive)으로 정의되므로, 순회 또한 서브 트리에 대해 순환적으로 반복 완성.
    * **탐색 기준**: 왼쪽 서브 트리를 오른쪽 서브 트리보다 **먼저** 방문한다.

### 25.1 순회 종류 (Traversal Types)
> **D**: 현재 노드(Data), **L**: 왼쪽 서브 트리(Left), **R**: 오른쪽 서브 트리(Right)

| 종류 | 순서 | 설명 |
| :--- | :--- | :--- |
| **전위 순회 (Preorder)** | **D $\rightarrow$ L $\rightarrow$ R** | 1. 현재 노드 **D**를 처리.<br>2. 왼쪽 서브 트리 **L**로 이동.<br>3. 오른쪽 서브 트리 **R**로 이동. |
| **중위 순회 (Inorder)** | **L $\rightarrow$ D $\rightarrow$ R** | 1. 왼쪽 서브 트리 **L**로 이동.<br>2. 현재 노드 **D**를 처리.<br>3. 오른쪽 서브 트리 **R**로 이동. |
| **후위 순회 (Postorder)** | **L $\rightarrow$ R $\rightarrow$ D** | 1. 왼쪽 서브 트리 **L**로 이동.<br>2. 오른쪽 서브 트리 **R**로 이동.<br>3. 현재 노드 **D**를 가장 나중에 처리. |

---

## 26. 순회 알고리즘의 응용
* **폴더 용량 계산 (Folder Size Calculation)**
    * 컴퓨터의 폴더 구조는 이진 트리(혹은 일반 트리) 구조임.
    * **로직**: 전체 용량 = (현재 폴더 파일 용량) + (하위 폴더들의 용량 합).
    * **적합한 순회**: **후위 순회 (Postorder)**.
        * *이유*: 상위 폴더의 용량을 계산하려면, 하위 폴더의 용량 계산이 **먼저** 끝나야 하기 때문.

---

## 27. 스레드 이진 트리 (Threaded Binary Tree)
* **정의**: 재귀 호출(시스템 스택 사용) 없이 순회할 수 있도록 수정한 이진 트리.
* **구조적 특징**:
    * **Thread 활용**: 자식 노드가 없는 경우(NULL), 링크 필드를 NULL 대신 **순회 순서상의 다른 노드(선행/후행 노드)**를 가리키도록 설정.
* **노드 구조 확장**:
    * `isThread` 필드 추가: 현재 링크가 실제 자식 노드 포인터인지, 아니면 스레드(순회용 포인터)인지 구별하기 위한 태그(Tag).

---

## 28. 이진 탐색 트리 (BST: Binary Search Tree)
* **정의**: 이진 트리를 탐색용 자료구조로 사용하기 위해, 원소 크기에 따라 노드 위치를 정의한 것.
* **탐색 기준**: 값이 큰가 작은가?

### 28.1 BST의 핵심 조건
1.  모든 원소는 **서로 다른 유일한 키(Key)**를 갖는다.
2.  **왼쪽** 서브 트리의 키 < **루트**의 키.
3.  **오른쪽** 서브 트리의 키 > **루트**의 키.
4.  왼쪽과 오른쪽 서브 트리도 모두 이진 탐색 트리여야 한다.

---

## 29. 이진 탐색 트리의 연산 (Operations)

### 29.1 삽입 연산 (Insertion)
1.  **탐색 수행**: 삽입할 원소와 같은 원소가 이미 트리에 있는지 확인 (중복 불가).
2.  **삽입 위치 결정**: 탐색이 **실패한 위치(NULL)**가 곧 새로운 원소가 들어갈 자리임.

### 29.2 삭제 연산 (Deletion)
1.  **탐색 수행**: 삭제할 노드의 위치를 찾는다.
2.  **노드 삭제 및 재구성 (Reconstruction)**:
    * 삭제 후에도 BST의 성질(대소 관계)을 유지해야 하므로 후속 처리가 필요함.
    * **Case 1 (단말 노드)**: 그냥 삭제 (부모의 링크를 NULL로).
    * **Case 2 (자식이 1개)**: 삭제된 노드의 자식을 부모 노드와 직접 연결.
    * **Case 3 (자식이 2개)**:
        * 왼쪽 서브 트리에서 **가장 큰 값** 혹은 오른쪽 서브 트리에서 **가장 작은 값**을 찾아 대체한다.

# [Study] 고급 트리 구조: AVL 트리와 힙 (02/11)

## 30. AVL 트리 (Adelson-Velsky and Landis Tree) 
* **정의**: 각 노드에서 왼쪽 서브 트리와 오른쪽 서브 트리의 **높이 차이가 1 이하**인 균형 이진 탐색 트리.
* **목표**: 트리가 한쪽으로 치우치는(Skewed) 현상을 방지하여 탐색 효율 $O(\log n)$을 보장함.

### 30.1 AVL 트리의 특징
1.  **BST 속성 유지**: `왼쪽 서브 트리 < 부모 노드 < 오른쪽 서브 트리`의 크기 관계를 갖는다.
2.  **균형 인수 (Balance Factor, BF)**:
    * 공식: $BF = \text{Height}(Left) - \text{Height}(Right)$
    * 제약: 모든 노드의 균형 인수는 **$\{-1, 0, 1\}$**만 가질 수 있다.
3.  **자가 균형 (Self-Balancing)**: 삽입/삭제로 인해 균형 인수가 범위를 벗어나면(예: 2, -2), **회전(Rotation)** 연산을 통해 즉시 균형을 맞춘다.

---

## 31. 힙 (Heap) 
* **정의**: **완전 이진 트리(Complete Binary Tree)**에 있는 노드 중에서 키값이 가장 큰 노드나 가장 작은 노드를 찾기 위해 만든 자료구조.
* **용도**: 우선순위 큐(Priority Queue) 구현, 힙 정렬(Heap Sort).

### 31.1 힙의 종류
| 종류 | 정의 | 부모-자식 관계 | 루트 노드 |
| :--- | :--- | :--- | :--- |
| **최대 힙 (Max Heap)** | 키값이 **가장 큰** 노드를 찾기 위함. | $Parent \ge Child$ | **최대값** (Maximum) |
| **최소 힙 (Min Heap)** | 키값이 **가장 작은** 노드를 찾기 위함. | $Parent \le Child$ | **최소값** (Minimum) |

---

## 32. 힙의 삽입 연산 (Insertion)
> **핵심 로직**: "일단 끝에 넣고, 부모와 비교하며 올라간다 (Up-Heap / Bubble-Up)"

1.  **구조적 확장**:
    * 완전 이진 트리의 조건을 만족하기 위해 **$n+1$번 자리(마지막 노드의 다음 위치)**에 노드를 확장한다.
    * 그 자리에 삽입할 원소를 임시 저장한다.
2.  **위치 찾기 (Up-Heap)**:
    * **비교**: 현재 위치에서 **부모 노드**와 크기를 비교한다.
    * **교환(Swap)**:
        * 조건: `{부모 키값 $\ge$ 삽입 원소 키값}` (최대 힙 기준) 관계가 **성립하지 않으면**,
        * 부모 노드와 자리를 서로 바꾼다.
    * 조건이 만족하거나 루트에 도달할 때까지 반복한다.

---

## 33. 힙의 삭제 연산 (Deletion)
> **핵심 로직**: "루트만 삭제 가능. 끝 원소를 루트로 올리고, 자식과 비교하며 내려간다 (Down-Heap / Bubble-Down)"

1.  **루트 삭제**: 힙에서는 오직 **루트 노드**의 원소만 삭제 및 반환 가능하다.
2.  **구조적 재조정**:
    * 원소의 개수가 $n-1$개로 줄어야 하므로, **힙의 가장 마지막 노드($n$번 노드)**를 빈 루트 자리로 옮긴다.
3.  **제자리 찾기 (Down-Heap)**:
    * 완전 이진 트리 내에서 루트에 임시 저장된 원소(원래 마지막에 있던 녀석)의 제자리를 찾는다.
    * 자식 노드들과 비교하여 힙 속성(최대/최소)을 만족할 때까지 아래로 교환하며 내려간다.
