# [Study] 자료구조 기본 (02/10)

## 1. 자료구조 (Data Structure) 개요
* **정의**: 자료를 효율적으로 표현, 저장, 처리할 수 있도록 정리하는 것.
* **목표**: 자료를 **빠르게 탐색(Search)** 하는 것.

### 1.1 자료구조의 분류
1.  **단순 구조 (Simple)**
    * 정수(Integer), 실수(Float), 문자(Char), 문자열(String) 등의 기본 자료형.
2.  **선형 구조 (Linear)**
    * 자료들 사이의 관계가 **1:1 관계**.
    * 종류: `{순차 리스트, 연결 리스트, 스택, 큐, 데크}`
3.  **비선형 구조 (Non-Linear)**
    * 자료들 사이의 관계가 **1:多, 多:多 관계**.
    * 종류: `{트리, 그래프}`
4.  **파일 구조 (File)**
    * 서로 관련 있는 필드로 구성된 레코드의 집합인 파일에 대한 구조.
    * 종류: `{순차 파일, 색인 파일, 직접 파일}`

---

## 2. 컴퓨터 구조 기초
* **2의 보수 (2's Complement)**: `1의 보수 + 1`

---

## 3. 추상화와 구체화 (Abstraction vs Concretization)

### 3.1 개념 비교
| 구분 | 내용 | 비고 |
| :--- | :--- | :--- |
| **자료의 추상화** | 기억할 대상의 구별되는 특징만을 단순화하여 기억하는 기능. | |
| **추상 자료형 (ADT)** | 자료와 연산자의 특성을 논리적으로 추상화하여 정의한 자료형. | |
| **추상화 (Abstraction)** | **"무엇인가? (What)"**를 논리적으로 정의. | ADT, 알고리즘 정의 |
| **구체화 (Concretization)** | **"어떻게 할 것인가? (How)"**를 실제적으로 표현. | 자료형, 프로그램 구현 |

---

## 4. 알고리즘 (Algorithm)
* **정의**: 문제 해결 방법을 추상화하여 단계적 절차를 논리적으로 기술해 놓은 것.

### 4.1 알고리즘의 5가지 조건
1.  **입력 (Input)**: 알고리즘 수행에 필요한 자료가 외부에서 입력으로 제공될 수 있어야 함.
2.  **출력 (Output)**: 수행 후 하나 이상의 결과를 출력해야 함.
3.  **명확성 (Definiteness)**: 수행할 작업의 내용과 순서를 나타내는 명령어들은 명확하게 명세되어야 함.
4.  **유한성 (Finiteness)**: 알고리즘은 수행한 뒤 반드시 종료되어야 함.
5.  **효과성 (Effectiveness)**: 모든 명령어들은 기본적이며 실행 가능해야 함.

---

## 5. 소프트웨어 설계 원칙 (Module)
* **응집도 (Cohesion)**: 함수(모듈) 안에서 관련 있는 기능끼리 모아 놓은 정도.
* **결합도 (Coupling)**: 모듈과 모듈 사이가 얼마나 의존적으로 엮여 있는가.
* **설계 목표**: **응집도는 높이고(High Cohesion), 결합도는 낮춰야(Low Coupling) 함.**

---

## 6. 메모리와 포인터 (Memory & Pointer)

### 6.1 연산의 방향
* **포인터 연산**: `주소` $\rightarrow$ `값` (Dereferencing)
* **레퍼런스 연산**: `값` $\rightarrow$ `주소` (Address-of)

### 6.2 복사(Copy)의 종류
* **얕은 복사 (Shallow Copy)**: 주소값만 복사하는 것 (동일한 메모리를 가리킴).
* **깊은 복사 (Deep Copy)**: 실제 데이터까지 메모리를 새로 할당해 복사하는 것 (독립적인 데이터).

---

## 7. 재귀 호출 (Recursion)
* **정의**: 자기 자신을 호출하여 순환 수행되는 것.
* **특징**:
    * 프로그램 크기를 줄이고, 코드를 간단하게 작성 가능.
    * 전체 문제를 한 번에 해결하기보다, 같은 유형의 하위 작업으로 분할하여 해결하는 것이 효율적일 때 사용.
* **베이스 케이스 (Base Case)**: 재귀 호출 과정을 반복하다 보면 한 번에 해결할 수 있을 정도로 분할된 작업 단위가 충분히 작아지는 단계 (종료 조건).

# [Study] 연결 자료구조와 연결 리스트 (02/10)

## 8. 리스트 (List)의 개요
* **정의**: 자료를 구조화하는 가장 기본적인 방법으로 데이터를 나열한 것.
* **구성 요소**:
    * **노드 (Node)**: 연결 자료구조에서 하나의 원소를 표현하기 위한 단위 구조.
    * **데이터 필드 (Data Field)**: 원소의 값을 저장 (형태에 따라 하나 이상의 필드로 구성).
* **선형 리스트 (Linear List)**:
    1.  **순서 리스트**: 자료들 간에 순서를 갖는 리스트.

### 8.1 자료구조의 순서
* **연결 자료구조 (Linked Data Structure)**: 자료의 **논리적인 순서**와 **물리적인 순서**가 불일치함 (포인터로 연결).
* **크기 계산**: `인덱스 번호 + 1` (컴퓨터적 개수) = `사이즈` (물리적 개수).

---

## 9. 연결 리스트 (Linked List) 구조
* **기본 구조**: `Head 노드` - `Current` - `Tail 노드`
* **주요 개념**:
    * **리스트 이름 (Head Pointer)**: 연결 리스트의 시작을 가리키는 포인터 변수.
    * **NULL 포인터**:
        * 연결 리스트의 마지막 노드의 링크 필드에 `NULL` 값을 저장하여 끝을 표시.
        * **공백 연결 리스트**: 포인터 변수(Head)에 `NULL` 저장.
    * **접근 방식**: 각 노드의 필드에 저장한 값은 **점(.) 연산자**를 사용해 액세스함.

---

## 10. 단순 연결 리스트 (Singly Linked List) 연산 

### 10.1 삽입 연산 (Insert)
1.  삽입할 노드를 준비한다.
2.  새 노드의 **데이터 필드**에 값을 저장한다.
3.  새 노드의 **링크 값(Next)**을 지정한다 (삽입할 위치의 다음 노드를 가리킴).
4.  리스트의 **앞 노드(Previous Node)**에 새 노드를 연결한다.

### 10.2 삭제 연산 (Remove)
1.  삭제할 노드의 **앞 노드**를 찾는다.
2.  앞 노드의 링크 필드에 **삭제할 노드의 링크 필드값(다음 노드 주소)**을 저장한다.
3.  삭제한 노드의 앞 노드와 삭제한 노드의 다음 노드를 논리적으로 연결한다. (이후 메모리 해제)

---

## 11. 고급 연결 리스트 (Advanced Linked List)

### 11.1 원형 연결 리스트 (Circular Linked List)
* **정의**: 연결 리스트에서 **마지막 노드**가 리스트의 **첫 번째 노드**를 가리키게 하여 구조를 원형으로 만든 리스트.

### 11.2 이중 연결 리스트 (Doubly Linked List) 
* **정의**: 양쪽 방향으로 순회할 수 있도록 노드를 연결한 리스트.
* **구조**:
    * **`llink` (Left Link)**: 왼쪽(이전) 노드와 연결하는 포인터.
    * **`rlink` (Right Link)**: 오른쪽(다음) 노드와 연결하는 포인터.

---

## 12. 이중 연결 리스트의 연산 로직

### 12.1 노드 삽입 방법 (Insertion Logic)
> *주의: 포인터 갱신 순서가 중요함 (기존 링크를 끊기 전에 주소를 백업해야 함).*

1.  삽입할 노드(`New`)를 준비하고 데이터 필드에 값을 저장한다.
2.  **오른쪽 연결**: `New`의 `rlink`에 `왼쪽 노드(Left)`의 `rlink` 값(기존의 오른쪽 노드 주소)을 저장한다.
3.  **왼쪽 연결**: `New`의 `llink`에 `왼쪽 노드(Left)`의 주소를 저장한다.
4.  **기존 노드 갱신 1**: `왼쪽 노드(Left)`의 `rlink`에 `New`의 주소를 저장한다.
5.  **기존 노드 갱신 2**: `오른쪽 노드(Right)`의 `llink`에 `New`의 주소를 저장한다.
6.  모든 노드가 순서대로 연결된다.

### 12.2 노드 삭제 과정 (Deletion Logic)
1.  삭제할 노드(`Target`)의 **오른쪽 노드**와 **왼쪽 노드**를 찾는다.
2.  **왼쪽 노드 갱신**: `삭제할 노드의 왼쪽 노드`의 `rlink`에 `삭제할 노드의 오른쪽 노드 주소`를 저장한다.
3.  **오른쪽 노드 갱신**: `삭제할 노드의 오른쪽 노드`의 `llink`에 `삭제할 노드의 왼쪽 노드 주소`를 저장한다.
4.  노드가 순서대로 연결된다. (삭제된 노드는 메모리 해제)

---

## 13. [Core] C언어 메모리 관리 및 안전성 (Memory Safety)
> **아키텍트의 조언**: "C언어에서 `malloc`은 빚을 지는 것과 같습니다. `free`로 갚지 않으면 시스템 파산(Crash)을 초래합니다."

### 13.1 동적 할당의 정석 (Allocation Pattern)
* **원칙**: 메모리 요청(`malloc`) 직후에는 반드시 **성공 여부(`NULL` 체크)**를 검증해야 한다.
* **초기화**: 할당된 메모리에 쓰레기 값(Garbage Value)이 남지 않도록 `memset`이나 `calloc` 사용을 권장.

```c
// [Good Practice] 안전한 할당 패턴
Node* newNode = (Node*)malloc(sizeof(Node));

if (newNode == NULL) {
    // 엣지 케이스 처리: 시스템 메모리 부족
    fprintf(stderr, "[Error] Memory allocation failed.\n");
    exit(1); 
}
// 할당 성공 후 데이터 초기화 필수
newNode->next = NULL;


```
# [Study] 스택의 이해 (02/11)

## 14. 스택 (Stack) 개요
* **정의**: 접시를 쌓듯이 자료를 차곡차곡 쌓아 올린 형태의 자료구조.
* **구조적 특징**:
    * **후입선출 (LIFO: Last-In First-Out)**: 마지막에 삽입한 원소가 맨 위에 있다가 가장 먼저 삭제되는 구조.
    * **접근 제어**: 스택에 저장된 원소는 **Top**으로 정한 곳에서만 접근 가능.
* **주요 연산**:
    * **`push`**: 삽입 연산 (Top 증가).
    * **`pop`**: 삭제 연산 (Top 감소, 데이터 반환).

---

## 15. 시스템 스택 (System Stack)
* **목표**: 프로그램에서의 함수 호출(Call)과 복귀(Return)에 따른 수행 순서를 관리.
* **동작 원리**:
    1.  **호출 순서**: 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀함 (LIFO).
    2.  **스택 프레임 (Stack Frame)**:
        * 함수 호출 발생 시, 수행에 필요한 정보(지역변수, 매개변수, 복귀 주소 등)를 저장하는 단위.
        * 시스템 스택에 `push` 됨.
    3.  **복귀 과정**:
        * 함수 실행이 끝나면 시스템 스택의 **Top 원소(해당 함수의 프레임)**를 `pop` 하여 삭제.
        * 프레임에 저장된 복귀 주소를 확인하여 호출한 지점으로 복귀.
    4.  **종료**: 함수 호출과 복귀를 반복하다 전체 프로그램 수행이 종료되면 시스템 스택은 **공백 스택(Empty)**이 됨.

---

## 16. 수식의 표기법 (Expression Notations)

### 16.1 표기법의 종류
| 종류 | 설명 | 예시 (A+B) |
| :--- | :--- | :--- |
| **전위 표기법 (Prefix)** | 연산자를 피연산자 **앞**에 표기. | `+AB` |
| **중위 표기법 (Infix)** | 연산자를 피연산자 **가운데** 표기 (일반적인 수식). | `A+B` |
| **후위 표기법 (Postfix)** | 연산자를 피연산자 **뒤**에 표기. | `AB+` |

---

## 17. 스택을 활용한 수식 알고리즘

### 17.1 중위 표기법 $\rightarrow$ 후위 표기법 변환 알고리즘
> *컴퓨터 내부에서 스택을 사용하여 변환하는 절차*

1.  **왼쪽 괄호 `(`**: 만나면 무시하고 다음 문자를 읽는다.
2.  **피연산자 (Operand)**: 만나면 즉시 **출력**한다.
3.  **연산자 (Operator)**: 만나면 **스택에 삽입(`push`)**한다.
4.  **오른쪽 괄호 `)`**: 만나면 스택을 **`pop`하여 출력**한다.
5.  **수식 종료**: 수식이 끝나면 스택이 공백이 될 때까지 계속 **`pop`하여 출력**한다.

### 17.2 후위 표기법 수식의 연산 (Evaluation)
> *변환된 수식(예: `AB+`)을 계산하는 절차*

1.  **피연산자**: 만나면 스택에 **`push`**한다.
2.  **연산자**:
    * 만나면 필요한 만큼의 피연산자(보통 2개)를 스택에서 **`pop`**한다.
    * 연산을 수행한다.
    * 연산 결과를 다시 스택에 **`push`**한다.
3.  **수식 종료**: 마지막으로 스택을 **`pop`**하여 최종 결과를 출력한다.


# [Study] 큐 (Queue)와 데크 (Deque) (02/11)

## 18. 큐 (Queue) 개요 
* **정의**: 스택과 비슷하게 삽입과 삭제의 위치가 제한되어 있는 유한 순서 리스트.
* **구조적 특징**:
    * **선입선출 (FIFO: First-In First-Out)**: 뒤(`Rear`)에서는 삽입만 하고, 앞(`Front`)에서는 삭제만 할 수 있는 구조.
* **주요 연산**:
    * **`enQueue`**: 삽입 연산.
    * **`deQueue`**: 삭제 연산.

### 18.1 스택과 큐의 비교
| 구분 | 삽입 연산 (Insert) | 위치 | 삭제 연산 (Delete) | 위치 |
| :--- | :--- | :--- | :--- | :--- |
| **스택 (Stack)** | `push` | Top | `pop` | Top |
| **큐 (Queue)** | `enQueue` | Rear | `deQueue` | Front |

### 18.2 큐의 포인터 관리
* **최대 크기**: `배열의 크기` (순차 큐 기준).
* **변수 역할**:
    * **`front`**: 저장된 **첫 번째 원소**의 인덱스를 저장.
    * **`rear`**: 저장된 **마지막 원소**의 인덱스를 저장.

---

## 19. 순차 큐(Linear Queue)의 문제점과 해결
> **문제 상황**: 잘못된 포화 상태 인식 (False Overflow)

* **현상**: 큐에서 삽입 및 삭제가 반복되면 앞부분(`front` 쪽)에 빈자리가 생기지만, `rear = n-1` 상태가 되어 포화 상태(Full)로 인식하고 더 이상 삽입을 수행하지 않음.

### 19.1 해결 방법
1.  **데이터 이동 (Shifting)**: 저장된 원소들을 배열의 앞부분으로 이동시키기. (비효율적: $O(n)$)
2.  **원형 큐 (Circular Queue)**: 1차원 배열을 사용하면서 논리적으로 배열의 처음과 끝이 연결되어 있다고 가정. (효율적: $O(1)$) 

### 19.2 순차 큐 vs 원형 큐 연산 비교
| 종류 | 삽입 위치 (Rear 계산) | 삭제 위치 (Front 계산) |
| :--- | :--- | :--- |
| **순차 큐** | `rear = rear + 1` | `front = front + 1` |
| **원형 큐** | $rear = (rear + 1) \pmod n$ | $front = (front + 1) \pmod n$ |
> *주석: `mod`는 나머지 연산자(%)를 의미하며, `n`은 큐의 크기.*

---

## 20. 데크 (Deque: Double-ended Queue) 
* **정의**: 큐 두 개 중 하나를 좌우로 뒤집어서 붙인 구조. 큐의 **양쪽 끝(Front & Rear)**에서 삽입과 삭제 연산을 모두 수행할 수 있도록 확장한 자료구조.
* **구현 전략**:
    * **순차 자료구조(배열)의 한계**: 양쪽 끝에서 연산 시 크기 변화와 원소의 순서 변화(Shift)가 많아 비효율적.
    * **권장 구현**: 양방향으로 연산 가능한 **이중 연결 리스트 (Doubly Linked List)** 사용.

---

## 21. 큐의 응용 (Applications)

### 21.1 운영체제 (OS)의 작업 큐
* **프린터 버퍼 큐 (Printer Buffer Queue)**:
    * CPU는 빠르고 프린터는 느림.
    * CPU에서 보낸 데이터를 순서대로(`FIFO`) 출력하기 위해 선입선출 구조 사용.
* **스케줄링 큐 (Scheduling Queue)**:
    * CPU 사용을 요청한 프로세스들의 순서를 스케줄링하기 위해 사용 (준비 큐, 대기 큐 등).

### 21.2 시뮬레이션과 큐잉 이론 (Queuing Theory)
* **정의**: 서비스 대기 행렬(Queue)과 대기 시간 등을 수학적으로 모델링하는 이론.
* **활용**: 은행 창구, 공항 입국 심사, 네트워크 패킷 처리 등 다양한 시스템의 성능 분석 및 최적화 시뮬레이션에 사용.
